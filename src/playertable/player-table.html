
<dom-module id="player-table">
  <script>
    // Not sure why this HTMLImports.whenReady is really needed.
    // Something about polymer initialization order.
    // I think we're not supposed to need this.
    HTMLImports.whenReady(() => {
      Polymer({
        is: 'player-table',

        properties: {
          serverBridge: Object,

          gameId: String,

          game: Object,

          players: {
            type: Array,
            value: function() { return []; },
          },

          pollInterval: {
            type: Number,
            value: 30,  // in seconds
          },

          playersTableDelegate: {
            type: Object,
            value: function() {
              return {
                getSchema: (() => {
                  return [
                    {property: "number", name: "Number"},
                    {property: "name", name: "Name"},
                    {property: "species", name: "Allegiance"},
                    {property: "lifeCode", name: "Life Code"},
                    {property: "rewards", name: "Rewards"},
                  ];
                }),
                getActions: (() => {
                  return [
                    {action: "delete", name: "Delete"},
                    {action: "infect", name: "Infect"},
                    {action: "revive", name: "Revive"},
                    {action: "ban", name: "Ban"},
                  ];
                }),
                create: this.getPlayerTableContents_.bind(this),
                update: this.getPlayerTableContents_.bind(this),
                doAction: this.doTableAction_.bind(this),
              };
            },
          },
        },

        attached: function() {
          this.fire('ghvz-dashlet-add-toolbar-button', { button: this.$.refresh });
        },

        observers: [
          "ready_(serverBridge, gameId)",
        ],

        ready_: function(serverBridge, gameId) {
          serverBridge.getGameById(gameId)
              .then((game) => {
                this.game = game;
                return this.serverBridge.findAllPlayersForGameId(game.id);
              })
              .then((players) => {
                this.players = players;
              });

          setInterval(this.pollPlayers_.bind(this), this.pollInterval * 1000);
        },

        pollPlayers_: function() {
          this.serverBridge.findAllPlayersForGameId(this.gameId)
            .then((players) => {
              this.players = players;
            });
        },

        doTableAction_: function(player, action) {
          console.log('do action', action, ' on player', player);
          if (action == "delete") {
            var index = this.players.indexOf(player);
            this.splice('players', index, 1);
          }
        },

        getPlayerTableContents_: function(player, propertyName) {
          if (propertyName == "name") {
            var div = document.createElement('div');
            div.appendChild(document.createTextNode(player.name));
            var iconButton = document.createElement('paper-icon-button');
            iconButton.style.opacity = ".5";
            iconButton.icon = "icons:open-in-new";
            iconButton.dataset.playerId = player.id;
            div.appendChild(iconButton);
            return div;
          }
          if (propertyName == 'lifeCode') {
            if (player.species == 'human') {
              if (player.lives.length) {
                return player.lives[player.lives.length - 1].lifeCode;
              }
            }
            return "";
          }
          if (propertyName == 'rewards') {
            let rewardNames = [];
            var rewardNamesByCategoryId = new Map();
            for (const rewardCategory of this.game.rewardCategories)
              rewardNamesByCategoryId.set(rewardCategory.id, rewardCategory.name);
            for (const rewardCategoryId of player.rewardCategoryIds)
              rewardNames.push(rewardNamesByCategoryId.get(rewardCategoryId));
            return rewardNames.join(", ");
          }
          if (propertyName == 'species') {
            if (player.species == 'human') {
              return 'Resistance';
            } else if (player.species == 'zombie') {
              return 'Horde';
            } else {
              return player.species;
            }
          }
          // if we dont return anything, auto-table will just by default create the text node
        },

        onDeletePlayer_: function(player) {
          var index = this.players.indexOf(player);
          if (index < 0) {
            console.error('Cant delete player, player not in list:', player);
            return;
          }
          this.splice('players', 1);
        },

        refresh_: function() {
          this.serverBridge.findAllPlayersForGameId(this.game.id)
              .then((players) => {
                if (players) {
                  this.players = [];
                  this.players = players;
                }
              });
        },
      });
    });
  </script>
  <template>
    <style>
      auto-table {
        display: block;
      }
    </style>
    <paper-icon-button
        id="refresh"
        icon="icons:refresh"
        on-tap="refresh_">
    </paper-icon-button>
    <auto-table
        id="playersTable"
        selectable
        delegate="[[playersTableDelegate]]"
        items="[[players]]">
    </auto-table>
  </template>
</dom-module>
