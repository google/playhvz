
<dom-module id="leaderboard-summary">
  <script>
    // Not sure why this HTMLImports.whenReady is really needed.
    // Something about polymer initialization order.
    // I think we're not supposed to need this.
    HTMLImports.whenReady(() => {
     Polymer({
      is: 'leaderboard-summary',

      properties: {
        serverBridge: Object,
        gameId: String,
        players: {
          type: Array,
          value: function() { return []; },
        },
        numToShow: {
          type: Number,
          value: 3,
        },
        pollInterval: {
          type: Number,
          value: 10,  // in seconds
        },

        leaderboardDelegate: {
          type: Object,
          value: function() {
            return {
              getSchema: (() => {
                return [
                  {property: "name", name: "Name"},
                  {property: "points", name: "Points"},
                ];
              }),
              getActions: (() => {
                return [
                  {action: "view", name: "View"},
                  {action: "grr", name: "Grr"},
                ];
              }),
              create: this.createLeaderboardContents_.bind(this),
              doAction: this.doTableAction_.bind(this),
            };
          },
        },
      },

      attached: function() {
        this.fire('ghvz-dashlet-add-toolbar-button', { button: this.$.refresh });
      },

      observers: [
      "ready_(serverBridge, gameId)",
      ],

      ready_: function(serverBridge, gameId) {
        serverBridge.findAllPlayersForGameId(gameId)
        .then((players) => {
          players.sort(Utils.byPoints);
          this.players = players.slice(0, this.numToShow);
        });

        setInterval(this.pollPlayers_.bind(this), this.pollInterval * 1000);
      },

      pollPlayers_: function() {
        this.serverBridge.findAllPlayersForGameId(this.gameId)
        .then((players) => {
          players.sort(Utils.byPoints);
          this.players = players.slice(0, this.numToShow);
        });
      },

      doTableAction_: function(player, action) {
        console.log('do action', action, ' on player', player);
        if (action == "view") {
          console.log("view");
        }
      },

      createLeaderboardContents_: function(player, propertyName) {
        if (propertyName == "name") {
          var div = document.createElement('div');
          div.appendChild(document.createTextNode(player.name));
          var iconButton = document.createElement('paper-icon-button');
          iconButton.classList.add("player-icon");
          iconButton.icon = "icons:open-in-new";
          iconButton.dataset.playerId = player.id;
          div.appendChild(iconButton);
          this.scopeSubtree(div); // So we can style it from our <style>
          return div;
        }
        // if we dont return anything, auto-table will just by default create the text node
      },

        refresh_: function() {
          this.serverBridge.findAllPlayersForGameId(this.gameId)
          .then((players) => {
            if (players) {
              players.sort(Utils.byPoints);
              this.players = players.slice(0, this.numToShow);
            }
          });
        },
      });
   });
 </script>
 <template>
  <style>
    auto-table {
      display: block;
    }
    .player-icon {
      opacity: .5;
    }
  </style>
  <paper-icon-button
  id="refresh"
  icon="icons:refresh"
  on-tap="refresh_">
</paper-icon-button>
<auto-table
id="leaderboardTable"
delegate="[[leaderboardDelegate]]"
items="[[players]]">
</auto-table>
</template>
</dom-module>
