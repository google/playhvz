<dom-module id="ghvz-fake-app">
<script>
  // Not sure why this HTMLImports.whenReady is really needed.
  // Something about polymer initialization order.
  // I think we're not supposed to need this.
  HTMLImports.whenReady(() => {
    Polymer({
      is: 'ghvz-fake-app',

      properties: {
        env: String,

        bridge: {
          type: Object,
        },

        userOptions: Array,

        alreadyReadUrl: {
          type: Boolean,
          value: false,
        },

        appsByUserId: {
          type: Object,
          value: () => ({}),
        },

        focusedUserId: {
          type: String,
          value: undefined,
        },
      },

      attached() {
        let idGenerator = new FakeIdGenerator();

        this.userOptions = [
          {loaded: false, focused: false, url: '', name: 'reggie', userId: FAKE_USER_IDS.reggieUserId, description: 'Registered, not admin, not joined'},
          {loaded: false, focused: false, url: '', name: 'minny', userId: FAKE_USER_IDS.minnyUserId, description: 'Registered, admin, not joined'},
          {loaded: false, focused: false, url: '', name: 'zella', userId: FAKE_USER_IDS.zellaUserId, description: 'Registered, admin, joined, human'},
          {loaded: false, focused: false, url: '', name: 'moldavi', userId: FAKE_USER_IDS.moldaviUserId, description: 'Registered, admin, joined, human, is keeper of the owls'},
          {loaded: false, focused: false, url: '', name: 'drake', userId: FAKE_USER_IDS.drakeUserId, description: 'Registered, not admin, joined, zombie'},
          {loaded: false, focused: false, url: '', name: 'zeke', userId: FAKE_USER_IDS.zekeUserId, description: 'Registered, not admin, joined, zombie'},
          {loaded: false, focused: false, url: '', name: 'jack', userId: FAKE_USER_IDS.jackUserId, description: 'Registered, not admin, joined, human'},
        ];

        this.bridge =
            new Bridge(
                idGenerator,
                new FakeBridge(
                    idGenerator,
                    new BatchedPolymerWriter(this, 'database')));

        let populate = Utils.getParameterByName('populate', 'light');
        assert(populate == 'light' || populate == 'heavy' || populate == 'none', "populate must be light, heavy, or none");
        if (populate != 'none') {
          populateUsers(this.bridge, FAKE_USER_IDS);
          populateGame(this.bridge, FAKE_USER_IDS, populate == 'heavy');
        }

        let userName = Utils.getParameterByName('user', 'zella');
        let userOption = this.userOptions.find((option) => option.name == userName);
        if (userOption)
          this.loadUser_(userOption.userId);
      },

      // This will only read the url once.
      // After that, will just load the main page.
      getUrl_() {
        if (this.alreadyReadUrl) {
          return '';
        } else {
          this.alreadyReadUrl = true;
          return window.location.pathname;
        }
      },

      loadUser_(userId) {
        let optionIndex = this.userOptions.findIndex((option) => option.userId == userId);
        let option = this.userOptions[optionIndex];

        if (option.focused) {
          return;
        }

        if (this.focusedUserId != null) {
          let focusedOptionIndex = this.userOptions.findIndex((option) => option.userId == this.focusedUserId);
          this.set('userOptions.' + focusedOptionIndex + '.focused', false);
          this.appsByUserId[this.focusedUserId].style.display = 'none';
        }
        if (!option.loaded) {
          let app = document.createElement('ghvz-app');
          app.bridge = this.bridge;
          app.url = this.getUrl_();
          app.userId = userId;
          this.appsByUserId[userId] = app;
          this.$.apps.appendChild(app);
        }
        this.appsByUserId[userId].style.display = 'block';

        this.set('userOptions.' + optionIndex + '.loaded', true);
        this.set('userOptions.' + optionIndex + '.focused', true);
        this.focusedUserId = userId;
      },

      loadUserTapped_(e) {
        this.loadUser_(e.model.option.userId);
      },

      unloadUserTapped_(e) {
        let option = e.model.option;
        let userId = option.userId;
        let optionIndex = this.userOptions.indexOf(option);

        if (this.focusedUserId == userId) {
          this.focusedUserId = null;
        }

        this.appsByUserId[userId].remove();
        delete this.appsByUserId[userId];
        this.set('userOptions.' + optionIndex + '.focused', false);
        this.set('userOptions.' + optionIndex + '.loaded', false);
      },
    });
  });
</script>
<style>
  :host {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
  }
  #options {
    display: flex;
    padding: 2px;
    position: relative;
    background-color: #add8e6;
  }
  .option {
    height: 24px;
    display: flex;
    align-items: center;
  }
  paper-button {
    background-color: #03A9F4;
    color: white;
    padding: 0;
  }
  .option[focused] paper-button {
    background-color: black;
  }
  paper-icon-button {
    width: 24px;
    height: 24px;
    padding: 0;
    margin-right: 8px;
  }
  #apps {
    flex-grow: 1;
    position: relative;
  }
</style>
<template>
  <div id="apps"></div>
  <div id="options">
    <template is="dom-repeat" items="[[userOptions]]" as="option">
      <div>
        <div class="option" focused$="[[option.focused]]">
          <paper-button
              raised
              on-tap="loadUserTapped_">
            [[option.name]]
          </paper-button>

          <paper-icon-button
              hidden$="[[!option.loaded]]"
              icon="icons:close"
              on-tap="unloadUserTapped_">
          </paper-icon-button>
        </div>
        <paper-tooltip fit-to-visible-bounds position="top">
          [[option.description]]
        </paper-tooltip>
      </div>
    </template>
  </div>
</template>
</dom-module>
